<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tkinter - Layout</title>
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="tkinter.css">
    <script src="prism.js"></script>
  </head>
  <body class="grid-container">
    <header>
  	<h1>tkinter - Layout</h1>
    </header>
    
	<nav>
	<h2>Inhalt</h2>
    <ul class="navul">
    <li class="navli"><a class="nava" href="tkinter.html">Startseite</a></li>
    <li class="navli"><a class="nava" href="tkinter-grundlagen.html">Grundlagen</a></li>
    <li class="navli"><a class="nava" href="tkinter-optionen.html">Optionen</a></li>
    <li class="navcurrent">Layout<ul class="navul">
		<li class="navli"><a class="nava" href="#Gridlayout">Gridlayout</a></li>
		<li class="navli"><a class="nava" href="#Packlayout">Packlayout</a></li>
		<li class="navli"><a class="nava" href="#Placelayout">Placelayout</a></li>
		<li class="navli"><a class="nava" href="#Fensterlayout">"Fensterlayout"</a></li>
	</ul></li>
    </ul>
    <h3>Widgets</h3>
    <ul class="navul">
    <li class="navli"><a class="nava" href="tkinter-ttk-button.html">Button</a></li>
    <li class="navli"><a class="nava" href="tkinter-tk-canvas.html">Canvas</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-checkbutton.html">Checkbutton</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-combobox.html">Combobox</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-entry.html">Entry</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-frame.html">Frame</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-label.html">Label</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-labeledscale.html">LabeledScale</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-labelframe.html">LabelFrame</a></li>
    <li class="navli"><a class="nava" href="tkinter-tk-listbox.html">Listbox</a></li>
    <li class="navli"><a class="nava" href="tkinter-menu.html">Menuwidgets</a></li>
    <li class="navli"><a class="nava" href="tkinter-tk-message.html">Message</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-notebook.html">Notebook</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-optionmenu.html">OptionMenu</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-panedwindow.html">PanedWindow</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-progressbar.html">Progressbar</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-radiobutton.html">Radiobutton</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-scale.html">Scale</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-scrollbar.html">Scrollbar</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-separator.html">Separator</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-sizegrip.html">Sizegrip</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-spinbox.html">Spinbox</a></li>
    <li class="navli"><a class="nava" href="tkinter-tk-text.html">Text</a></li>
    <li class="navli"><a class="nava" href="tkinter-tk-toplevel.html">Toplevel</a></li>
    <li class="navli"><a class="nava" href="tkinter-ttk-treeview.html">Treeview</a></li>
    <li class="navli"><a class="nava" href="tkinter-dialoge.html">Dialoge</a></li>
    <li class="navli">–</li>
    <li class="navli"><a class="nava" href="tkinter-events.html">Events</a></li>
    <li class="navli"><a class="nava" href="tkinter-widgetmethoden.html">Widgetmethoden</a></li>
    <li class="navli"><a class="nava" href="tkinter-bilder.html">Bilder</a></li>
    </ul>
	</nav>


    <main>


    <h2 id="Gridlayout">Gridlayout</h2>


    <section>
    <h3>Gridlayout</h3>
    <p>Das Grid-Layout basiert darauf, dass man Elemente in einer Art Tabelle anordnet. Es gibt Zeilen
        und Spalten. Elemente werden mit <code class="language-python">grid()</code> in Zellen gelegt.
        Per <code>rowspan</code> und <code>columnspan</code> können 
        mehrere Zeilen/Spalten von einem Widget überdeckt werden. Dann sorgt die Option 
        <code>sticky</code> 
        für das  Ausdehnen. Dieses funktioniert mit Einschränkungen: Es müssen Elemente in den span-Zeilen 
        enthalten sein, damit die Geometrie sichtbar funktioniert. Alternativ können Zeilen und Spalten 
        konfiguriert werden, wie es in den nächsten Abschnitten gezeigt wird. Folgendes Beispiel verdeutlicht das:</p>
    <a href="img/t-layout/gridlayout1.png" target="_blank"><img src="img/t-layout/gridlayout1.png" alt="Bild der Anwendung" class="bild" /></a>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("300x200")
        self._createWidgets()

    def _createWidgets(self):
        label00 = ttk.Label(self, relief=tk.GROOVE, text="abc")
        label00.grid(row=0, column=0, sticky=tk.N+tk.S+tk.W+tk.E)
        
        label01 = ttk.Label(self,  relief=tk.GROOVE, text="def")
        label01.grid(row=0, column=1, sticky=tk.N+tk.S+tk.W+tk.E)

        label02 = ttk.Label(self,  relief=tk.GROOVE, text='ghi')
        label02.grid(row=0, column=2, rowspan=2, sticky=tk.N+tk.S+tk.W+tk.E)

        # Kommentiert man dieses Label aus, dann wird auch label02
        # nicht mehr über 2 Reihen angezeigt
        label10 = ttk.Label(self,  relief=tk.GROOVE, text='aaa')
        label10.grid(row=1, column=0, sticky=tk.N+tk.S+tk.W+tk.E)

        button = ttk.Button(self, text='Quit', command=self.destroy)
        button.grid(row=2, column=0, columnspan=3, sticky=tk.W+tk.E)
        
if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>


    <section>
    <h3>Parameter der Grid-Methode</h3>
    <p>Die Methode <code class="language-python">grid()</code> kennt folgende Parameter:</p>
    <table>
    <tr><th>Parametername</th><th>Beschreibung</th></tr>
    <tr><td>column</td><td>Spaltennummer, optional, default=0</td></tr>
    <tr><td>columnspan</td><td>Anzahl der zusätzlich benötigten Spalten</td></tr>
    <tr><td>in_</td><td>Das Widget wird in ein anderes Widget eingefügt</td></tr>
    <tr><td>ipadx, ipady</td><td>inneres Padding, zusätzlicher Platz links und rechts 
        bzw. oben und unten innerhalb des Widgets.
        Diesen Platz sieht man nicht, wenn sich das Widget voll ausdehnt.</td></tr>
    <tr><td>padx, pady</td><td>äußeres Padding, zusätzlicher Platz links und rechts bzw. oben und unten. Diesen
        Platz sieht man auch, wenn das Widget sich voll ausdehnen darf.</td></tr>
    <tr><td>row</td><td>Zeilennummer, optional, default=0</td></tr>
    <tr><td>rowspan</td><td>Anzahl der zusätzlich benötigten Zeilen</td></tr>
    <tr><td>sticky</td><td>Kombination aus tk.N, tk.S, tk.W und tk.E. 
        <ul>
        <li>sticky=tk.N+tk.S dehnt ein Widget horizontal,</li>
        <li>sticky=tk.E+tk.W dehnt ein Widget vertikal,</li>
        <li>sticky=tk.N+tk.E+tk.S+tk.W dehnt in beide Richtungen</li>
        </ul>    
        </td></tr>
    </table>    
    <p>Das folgende Beispiel zeigt äußeres und inneres Padding: 
        <code>label00</code> wird mit einem
        Außenabstand zum Rand gezeichnet, obwohl es sich ausdehnen darf. 
        <code>label01</code> darf 
        sich nicht ausdehnen, bekommt aber durch inneres Padding etwas mehr Innenraum.
        <code>label02</code> hingegen darf sich ausdehnen, 
        bekommt aber keinen Padding.</p>
    <a href="img/t-layout/gridlayout2.png" target="_blank"><img src="img/t-layout/gridlayout2.png" alt="Bild der Anwendung" class="bild" /></a>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("300x200")
        self._createWidgets()

    def _createWidgets(self):
        self.rowconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)
        self.rowconfigure(2, weight=1)
        
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        self.columnconfigure(2, weight=1)

        label00 = ttk.Label(self, relief=tk.GROOVE, text="abc")
        label00.grid(row=0, column=0, sticky=tk.N+tk.S+tk.W+tk.E, padx=10, pady=10)
        
        label01 = ttk.Label(self,  relief=tk.GROOVE, text="def")
        label01.grid(row=0, column=1, ipadx=10, ipady=10)

        label02 = ttk.Label(self,  relief=tk.GROOVE, text='ghi')
        label02.grid(row=0, column=2, sticky=tk.N+tk.S+tk.W+tk.E)
        
        button = ttk.Button(self, text='Quit', command=self.destroy)
        button.grid(row=1, column=0, columnspan=3)       
        

if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>


    <section>
    <h3>Gridlayout bei variabler Fenstergröße</h3>
    <p>Das eigentliche Ziel des Layouts ist es, die Widgets in einem Fenster so anzuordnen, dass
        auch bei sich ändernder Fenstergröße die Widgets passend angeordnet werden. Das Ziel kann 
        leicht erreicht werden, wenn man mit <code class="language-python">rowconfigure()</code> und
        <code class="language-python">columnconfigure()</code> Zeilen und Spalten eine Größe oder
        alternativ ein Gewicht zuordnen. Gewicht bedeutet eine relative Breite oder Höhe.</p> 
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("300x200")
        self._createWidgets()

    def _createWidgets(self):
        self.rowconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)
        self.rowconfigure(2, weight=1)
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        self.columnconfigure(2, weight=1)

        label00 = ttk.Label(self, relief=tk.GROOVE, text="abc")
        label00.grid(row=0, column=0, sticky=tk.N+tk.S+tk.W+tk.E)
        
        label01 = ttk.Label(self,  relief=tk.GROOVE, text="def")
        label01.grid(row=0, column=1, sticky=tk.N+tk.S+tk.W+tk.E)

        label02 = ttk.Label(self,  relief=tk.GROOVE, text='ghi')
        label02.grid(row=0, column=2, rowspan=2, sticky=tk.N+tk.S+tk.W+tk.E)

        # Unabhängig von den folgenden beiden Zeilen wird label02
        # angezeigt
        #label10 = ttk.Label(self,  relief=tk.GROOVE, text='aaa')
        #label10.grid(row=1, column=0, sticky=tk.N+tk.S+tk.W+tk.E)

        button = ttk.Button(self, text='Quit', command=self.destroy)
        button.grid(row=2, column=0, columnspan=3, sticky=tk.W+tk.E)
        
if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>

    
    <section>
    <h3>Gridlayoutmethoden im Überblick</h3>
    <table>
    <tr><th>Funktion</th><th>Parameter</th><th>Rückgabewert</th><th>Beschreibung</th></tr>
    <tr><td>w.columnconfigure(spalte, option=wert, …)</td><td>spalte: Nummer der Spalte, 
        option=wert: Optionen für Spalte. Optionen können minsize (Mindestbreite), 
        pad (Extraabstand in Pixeln) oder weight (Relative Breite Spalte) sein</td>
        <td>-</td><td>Verändert die Konfiguration der Spalte</td></tr>
    <tr><td>w.grid_bbox(spalte1, reihe1, spalte2, reihe2)</td>
        <td>spalte, reihe optionale Spalten- und Reihennummern</td>
        <td>4-Tupel</td><td>Gibt die Geometrie als Rechteck der Elemente in 
        den angegebenen Spalten/Reihen zurück</td></tr>
    <tr><td>w.grid_forget()</td><td>-</td><td>-</td><td>w wird aus dem Grid gelöst, 
        ist aber weiterhin da und kann per grid() wieder eingefügt werden</td></tr>
    <tr><td>w.grid_info()</td><td>-</td><td>Dictionary</td><td>Beschreibt die Lage 
        eines Widgets, beispielsweise eines Labels, 
        innerhalb des Grid-Layouts. Es werden alle Gridattribute mit ihren 
        zugehörigen Werten zurückgeliefert. </td></tr>
    <tr><td>w.grid_location(x, y)</td><td>x, y Screenkoordinaten</td><td>2-Tupel</td><td>Gibt 
        die Zelle (spalte, reihe) zurück </td></tr>
    <tr><td>w.grid_propagate(prop)</td><td>True oder False</td><td>-</td><td>False: Das Widget
        teilt dem Fenster seine Größe 
        nicht mit. Es wird also nicht in die Gridlayout-Größenberechnung miteinbezogen. 
        Nützlich, wenn man festgelegte konstante Breiten/Höhen erreichen will.</td></tr>
    <tr><td>w.grid_remove()</td><td>-</td><td>-</td><td>wie grid_forget(), 
        die Gridproportionen werden aber gemerkt und genutzt, 
        wenn das Widget erneut eingefügt wird </td></tr>
    <tr><td>w.grid_size()</td><td>-</td><td>2-Tupel</td><td>Gibt die Anzahl der Spalten 
        und Reihen im Grid-Layout von w an </td></tr>
    <tr><td>w.grid_slaves(reihe, spalte)</td><td>reihe: optionale Reihe, 
        spalte: optionale Spalte</td><td>Liste von Widgets</td><td>Gibt eine Liste von 
        Widgets zurück, die sich in der Reihe/Spalte oder im gesamten Grid befinden</td></tr> 
    <tr><td>w.rowconfigure(zeile, option=wert, …)</td><td colspan="3" class="see">wie w.columnconfigure(…), 
        nur mit Zeilen</td></tr> 
    </table>
    </section>


    <h2 id="Packlayout">Packlayout</h2>


    <section>
    <h3>Packlayout</h3>
    <p>Beim Packlayout werden die Widgets von links nach rechts, oder oben nach unten mit 
        <code class="language-python">pack()</code>eingefügt. Der Parameter 
        <code>fill</code> bestimmt die Richtung, in die sich ein
        Widget ausdehnen darf, der Parameter <code>expand</code> bestimmt,
        ob das Widget extra Raum bekommen darf.</p>
    <a href="img/t-layout/packlayout1.png" target="_blank"><img src="img/t-layout/packlayout1.png" alt="Bild der Anwendung" class="bild" /></a>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("300x200")
        self._createWidgets()

    def _createWidgets(self):
        label00 = ttk.Label(self, relief=tk.GROOVE, text="abc")
        label00.pack(fill=tk.X)
        
        label01 = ttk.Label(self,  relief=tk.GROOVE, text="def")
        label01.pack(fill=tk.Y, expand=tk.YES)

        label02 = ttk.Label(self,  relief=tk.GROOVE, text='ghi')
        label02.pack(fill=tk.BOTH, expand=tk.YES)
        
        button = ttk.Button(self, text='Quit', command=self.destroy)
        button.pack()

if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    <p>Hier darf sich <code>label00</code> horizontal ausdehnen 
        und den verfügbaren Platz einnehmen, <code>label01</code> und 
        <code>label02</code> dürfen sich vertikal ausdehnen und 
        konkurrieren um den verfügbaren Platz. Während <code>label01</code>
        sich nicht horizontal ausdehnen darf, darf <code>label02</code> sich
        in beide Richtungen erstrecken.</p>
    </section>


    <section>
    <h3>Parameter der Pack-Methode</h3>
    <table>
    <tr><th>Parametername</th><th>Beschreibung</th></tr>
    <tr><td>after, before</td><td>Ändert die Pack-Reihenfolge. Dieses Widget wird nach / vor einem mit after / before 
        anzugebenen Widget gepackt</td></tr>
    <tr><td>anchor</td><td>Gibt es mehrere Möglichkeiten für ein Widget, sich zu plazieren, kann mit anchor 
        bestimmt werden, wohin es plaziert wird. tk.N, tk.S, tk.W, tk.E, tk.CENTER (default)</td></tr>
    <tr><td>expand</td><td>tk.YES, tk.NO (default), gibt an, ob das Widget seinen Freiraum nutzen darf</td></tr>
    <tr><td>fill</td><td>tk.NONE: nichts ausfüllen (default), tk.X: in X-Richtung den Platz füllen, 
        tk.Y: in Y-Richtung, tk.BOTH: in X- und Y-Richtung den Platz ausfüllen</td></tr>
    <tr><td>in_</td><td>Das Widget wird in ein anderes Widget eingefügt</td></tr>
    <tr><td>ipadx, ipady</td><td>Zusätzlicher Innenabstand</td></tr>
    <tr><td>padx, pady</td><td>Zusätzlicher Außenabstand</td></tr>
    <tr><td>side</td><td>TK.BOTTOM, tk.TOP (default), tk.LEFT, tk.RIGHT, Gibt die Seite an, an die das 
        Widget gepackt wird</td></tr>
    </table>
    <p>Im folgenden Beispiel kommt es sehr auf die Reihenfolge der Labels an. Ändert man diese bei gleichen
        Pack-Parametern, dann ändert sich auch gleichzeitig die Ausdehnung:</p>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("300x200")
        self._createWidgets()

    def _createWidgets(self):
        labelLeft = ttk.Label(self, relief=tk.GROOVE, text="LEFT")
        labelLeft.pack(side=tk.LEFT, fill=tk.BOTH, expand=tk.YES)

        labelRight = ttk.Label(self,  relief=tk.GROOVE, text='RIGHT')
        labelRight.pack(side=tk.RIGHT, fill=tk.BOTH, expand=tk.YES)
        
        labelTop = ttk.Label(self,  relief=tk.GROOVE, text="TOP")
        labelTop.pack(side=tk.TOP, fill=tk.BOTH, expand=tk.YES)

        labelCenter = ttk.Label(self, relief=tk.GROOVE, text="CENTER")
        labelCenter.pack(anchor=tk.CENTER, fill=tk.BOTH, expand=tk.YES)
        
        labelBottom = ttk.Label(self,  relief=tk.GROOVE, text='BOTTOM')
        labelBottom.pack(side=tk.BOTTOM, fill=tk.BOTH, expand=tk.YES)

if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>


    <section>
    <h3>Packlayoutmethoden im Überblick</h3>
    <table>
    <tr><th>Funktion</th><th>Parameter</th><th>Rückgabewert</th><th>Beschreibung</th></tr>
    <tr><td>w.pack_forget(), w.forget()</td><td>-</td><td>-</td><td>Entfernt das Widget aus 
        dem Layout und vergisst dabei alle pack()-Parameter.</td></tr>
    <tr><td>w.info()</td><td>-</td><td>Dictionary mit allen möglichen Pack-Parametern</td><td>Gibt die 
        aktuelle Pack-Konfiguration zurück.</td></tr>
    <tr><td>l.pack_propagate(prop)</td><td>True / False, tk.YES / tk.NO, 1/0</td><td>-</td><td>
        True: Größe des Layout-Widgets ändert sich, wenn Widgets dem Layout hinzugefügt werden. (Default)
        Sonst nicht</td></tr>
    <tr><td>l.pack_slaves(), l.slaves()</td><td>-</td><td>Array von Widgets</td><td>
        Gibt ein Array zurück, das alle im Layout-Widget enthaltenen Widgets zurückliefert.</td></tr>
    </table>
    <p>Im folgenden Beispiel bekommt man nichts zu sehen, wenn der Parameter von
        <code class="language-python">f.pack_propagate(1)</code> auf "0" gesetzt wird: Die Größe
        des Frames ändert sich dann nicht, wenn die Labels hinzugefügt werden:</p>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("200x200")
        self._createWidgets()

    def _createWidgets(self):
        f = ttk.Frame(self, relief=tk.SUNKEN)
        f.pack()
        f.pack_propagate(1)
        
        label1 = ttk.Label(f, relief=tk.GROOVE, text="Label1")
        label1.pack(padx=10, pady=10, side=tk.LEFT, expand=tk.YES, fill=tk.BOTH)
        
        label2 = ttk.Label(f,  relief=tk.GROOVE, text='Label2')
        label2.pack(padx=10, pady=10, side=tk.LEFT, expand=tk.YES, fill=tk.BOTH)
        
if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    
    <p>Gibt eine Liste von im Layout enthaltener Widgets aus:</p>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("200x200")
        self._createWidgets()

    def _createWidgets(self):
        f = ttk.Frame(self, relief=tk.SUNKEN)
        f.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH)
        
        label1 = ttk.Label(f, relief=tk.GROOVE, text="Label1")
        label1.pack(padx=10, pady=10, side=tk.LEFT, expand=tk.YES, fill=tk.BOTH)
        
        label2 = ttk.Label(f,  relief=tk.GROOVE, text='Label2')
        label2.pack(padx=10, pady=10, side=tk.LEFT, expand=tk.YES, fill=tk.BOTH)
        
        print(f.pack_slaves())
        
if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>


    <h2 id="Placelayout">Placelayout</h2>


    <section>
    <h3>Placelayout - absolut</h3>
    <p>Das Placelayout basiert darauf, dass Widgets mit <code class="language-python">place()</code>
        punktgenau positioniert werden. Tkinter 
        braucht hierfür nichts weiter zu berechnen und der Anwender ist für Größe und Position 
        der Widgets veantwortlich. Ferner gibt es die Möglichkeit, ein Widget relativ zur Größe
        des Layout-Widgets zu positionieren.</p>
    <p>Im folgenden Beispiel werden zwei Widgets positioniert. Eines oben links, das Andere unten rechts. Der 
        Parameter <code>anchor</code> bestimmt, welcher Ort des Labels an den 
        angegebenen Punkt plaziert wird.</p>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("200x200")
        self._createWidgets()

    def _createWidgets(self):
        label1 = ttk.Label(self, relief=tk.GROOVE, text="Label1")
        label1.place(x=0, y=0)
        
        label2 = ttk.Label(self, relief=tk.GROOVE, text="Label2")
        label2.place(anchor=tk.SE, x=200, y=200)
        
if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>


    <section>
    <h3>Placelayout - relativ</h3>
    <p>Neben der absoluten Positionierung bietet <code class="language-python">place()</code> die Möglichkeit, 
        ein Widget relativ zur Größe des Layout-Widgets zu positionieren.</p>
    
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("200x200")
        self._createWidgets()

    def _createWidgets(self):
        label1 = ttk.Label(self, relief=tk.GROOVE, text="Oben-Mitte")
        label1.place(relx=0.5, y=0)
        
        label2 = ttk.Label(self, relief=tk.GROOVE, text="Links-Mitte")
        label2.place(x=0, rely=0.5)

        label3 = ttk.Label(self, relief=tk.GROOVE,
                           text="Dieses Widget liegt in der Mitte")
        label3.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
        
        label4 = ttk.Label(self, relief=tk.GROOVE, text="Unten-Mitte")
        label4.place(relx=0.5, rely=1, anchor=tk.S)
        
if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    <p>Und schließlich lässt sich noch die Größe des Widgets relativ zum Layout-Widget per 
        <code>relwidth</code>, <code>relheight</code>angeben:</p>
    <a href="img/t-layout/placelayout-relwidth.png" target="_blank"><img src="img/t-layout/placelayout-relwidth.png" alt="Bild der Anwendung" class="bild" /></a>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("200x200")
        self._createWidgets()

    def _createWidgets(self):
        label1 = ttk.Label(self, relief=tk.GROOVE, text="Oben-Mitte")
        label1.place(x=0, y=0, relwidth=0.5, relheight=0.5)
        
        label2 = ttk.Label(self, relief=tk.GROOVE, text="Unten")
        label2.place(relx=0.5, rely=1, relwidth=0.5, anchor=tk.S)

if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>


    <section>
    <h3>Parameter der Place-Methode</h3>
    <table>
    <tr><th>Parametername</th><th>Beschreibung</th></tr>
    <tr><td>anchor </td><td>Ort im Widget, der positioniert werden soll: tk.NW, …, tk.SE, tk.CENTER</td></tr>
    <tr><td>bordermode </td><td>Bei tk.INSIDE (default): Rahmen des Layout-Widgets wird berücksichtigt, tk.OUTSIDE: Rahmen 
        im Layout-Widget bleibt komplett unberücksichtigt</td></tr>
    <tr><td>height, width</td><td>Absolute Höhe/Breite eines Widgets</td></tr>
    <tr><td>in_</td><td>Angabe eines anderen Layout-Widgets, in welches das Widget eingefügt werden soll</td></tr>
    <tr><td>relheight, relwidth </td><td>Relative Höhe/Breite eines Widgets, 0..1</td></tr>
    <tr><td>relx, rely</td><td>Relative Positionsangabe eines Widgets, 0..1</td></tr>
    <tr><td>x, y</td><td>Absolute Positionsangabe eines Widgets</td></tr>
    </table>
    <p>Im folgenden Beispiel werden Label in einem Frame mit einem 10 Pixel Rahmen plaziert. Die Label unterscheiden 
        sich im <code>bordermode</code>-Parameter:</p>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry("200x200")
        self._createWidgets()

    def _createWidgets(self):
        f = ttk.Frame(self, relief=tk.RAISED, borderwidth=10)
        f.pack(fill=tk.BOTH, expand=tk.YES)
        
        label1 = ttk.Label(f, relief=tk.GROOVE, text="INSIDE")
        label1.place(x=0, y=0, bordermode=tk.INSIDE)
        
        label2 = ttk.Label(f, relief=tk.GROOVE, text="OUTSIDE")
        label2.place(x=0, rely=0.5, bordermode=tk.OUTSIDE)

if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>


    <section>
    <h3>Packlayoutmethoden im Überblick</h3>
    <table>
    <tr><th>Funktion</th><th>Parameter</th><th>Rückgabewert</th><th>Beschreibung</th></tr>
    <tr><td>w.place_forget()</td><td>-</td><td>-</td><td>Entfert Widget aus dem Layout</td></tr>
    <tr><td>w.place_info()</td><td>-</td><td>Dictionary mit Place-Optionen</td><td>Gibt ein 
        Dictionary mit allen Place-Optionen zurück.</td></tr>
    <tr><td>w.place_slaves()</td><td>-</td><td>Array mit Widgets</td><td>Gibt ein Array mit allen 
        Widgets im aktuellen Layout zurück.</td></tr>
    </table>
    </section>


    <h2 id="Fensterlayout">Fensterlayout</h2>


    <section>
    <h3>Fensterlayout - kein echtes Layout</h3>
    <p>Das Fensterlayout ist kein echtes Layout, weil es sich nur auf die Verwaltung eines 
        einzelnen Fensters stützt. Zentrale Methode ist hier <code class="language-python">geometry()</code> mit 
        folgenden Möglichkeiten:</p>
    <ul>
    <li>w.geometry("100x200") - Fenster wird mit der Größe 100X200 Pixel erzeugt,</li>
    <li>w.geometry("100x200+20+50") - Fenster wird zusätzlich um x=+20 und y=+50 Pixel von der oberen linken 
        Bildschirmecke positioniert.</li>
    </ul>
    <p>Hat man mehrere Fenster und möchte deren Anordnung über- oder untereinander festlegen ("Stacking Order"), 
        helfen die folgenden Funktionen:</p>
    <ul>
    <li>w.lower(belowThis=None) - Fenster wird nach unten (unter das Fenster <code>belowThis</code>) verschoben</li>
    <li>w.tkraise(aboveThis=None) - Fenster wird nach oben (über das Fenster <code>aboveThis</code>) verschoben</li>
    </ul>
    <p>Folgendes Programm stellt drei <a href="tkinter-tk-toplevel.html" target="_blank">Toplevel-Fenster</a> vor, die 
        nach jeweils 500 ms neu übereinander angeordnet werden:</p>
    
    <a href="img/t-layout/fensterlayout-3toplevel-1.png" target="_blank"><img src="img/t-layout/fensterlayout-3toplevel-1.png" alt="Bild der Anwendung" class="bild" /></a>
    <pre><code class="language-python">import tkinter as tk
from tkinter import ttk

class A(tk.Tk):
    def __init__(self):
        super().__init__()
        self.geometry('400x200+100+100')
        self._createWidgets()

    def _createWidgets(self):
        self._currentTop = 0
        # drei Toplevel-Fenster mit unterschiedlichem Hintergrund
        self.w1 = tk.Toplevel(self, background='green')
        self.w2 = tk.Toplevel(self, background='red')
        self.w3 = tk.Toplevel(self, background='blue')
        # Geometrie, sollte überlappen
        self.w1.geometry('100x100+120+120')
        self.w2.geometry('100x100+150+150')
        self.w3.geometry('100x100+180+180')
        # Hauptfenster unter das erste Toplevel schieben 
        self.lower(belowThis=self.w1)
        # Starte den Timer
        self.after(500, self._lifter)

    def _lifter(self):
        self._currentTop = (self._currentTop + 1) % 3
        if self._currentTop == 0:
            self.w1.tkraise()
        elif self._currentTop == 1:
            self.w2.tkraise()
        else:
            self.w3.tkraise()
        self.after(500, self._lifter)
        
if __name__ == '__main__':
    window = A()
    window.mainloop()</code></pre>
    </section>
 
 
    </main>

    
    <footer>
    <p>&copy;2021 <a href="mailto:eike9000@web.de">E.Lange</a></p>
    </footer>
  </body>
</html>